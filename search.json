[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GEE_intento",
    "section": "",
    "text": "El siguiente es un intento de hacer el uso de quarto para hacer un blog donde se haran cosas para GEE y sirva parqa hacer un curso del mismo.\n\n\nEl link de la pagina link"
  },
  {
    "objectID": "index.html#pagina-con-los-post",
    "href": "index.html#pagina-con-los-post",
    "title": "GEE_intento",
    "section": "",
    "text": "El link de la pagina link"
  },
  {
    "objectID": "posts/Slope/Pendiente.html",
    "href": "posts/Slope/Pendiente.html",
    "title": "Pendiente",
    "section": "",
    "text": "Interactivo\nEn este post vamos a generar un mapa interactivo, la idea es ver que podemos hacer cosas interactivas dentro de Google Earth Engine (GEE), el pretexto va a ser calcular la pendiente de un conjunto de datos de Modelos Digitales de Elevación (DEM).\n\nNota\nEsto es un ejemplo no se recopmienda usar para hacer calculos reales ni importantes, aunque nos muestra cosas que tiene sentido las unidades de los resultados pueden no ser confiable.\n\n\n\nLa idea\nLa escases de agua es un problema a nivel mundial, el agua es de importancia vital para casi todas las atividades humanas. Por lo tanto es necesario tener un manejo adecuado del recurso y tener las mejores condiciones para su aprovechamiento. Una de las problemáticas con respecto al manejo de agua es el manejo de los acuiferos subterraneos y la recarga de los mismos.\nLa pendiente del terreno, es un elemento que se tiene que tener en consideración para determinar la zonas en las cuales podrian ser consideradas como zonas de recarga de los acuiferos. Un terreno con mucha pendiente generá que la velocidad del agua en la superficie sea alta, impidiendo que el agua se mantenga en una zona evitando la absorción en el subsuelo.\nLa idea es tomar a los paises y visualizar la pendiente en todo su territorio. Vamos a definir, los valores de la pendiente para determinar si el suelo tiene un buen potencial de recarga, la clasificación reportada es distinta en la literatura y esta depende del tipo de suelo, por lo cual, no hay un consenso entre los autores en la literatura el número de tipos de pendiente ni los valores respectivos. Aunque, si hay cierto consenso en que menos de \\(14-17\\%\\) es necesario para permitir que el agua se permee a los mantos acuiferos. En este caso vamos a tomar la siguiente definición.\n\n\n\nTable 1: Valores pendiente y su clasificación.\n\n\n\n\n\nPendiente\nValor\n\n\n\n\n0 - 3.15\nMuy bueno\n\n\n3.16 - 7.87.\nBueno\n\n\n7.88 - 14.87\nRegular\n\n\n14.87 - 44\nMalo\n\n\n44 -\nPesimo\n\n\n\n\n\n\nAhora veamos como podemos hacer un mapa donde mostremos la pendiente en las distintas regiones y que la tomar un país en partícular nos muestre la pendiente. Utilicemos el conjunto de datos de los DEMs de Copernicus que se encuentran dentro de GEE la cual nos de a una covertura global de las elevaciones a nivel global. Se utiliza la banda DEM que se encuentra dentro de todas las imágenes.\nvar dataset = ee.ImageCollection('COPERNICUS/DEM/GLO30');\nvar elevation = dataset.select('DEM');\nvar worldcountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nvar country = worldcountries.filter(ee.Filter.eq('country_na', 'Mexico'));\nvar palettes = require('users/gena/packages:palettes');\nLas siguientes declaraciones son simplemente la coleccion de los polígonos de los paises, una varialbe global llamada country que contendrá nuestro país seleccionado, las paletas de colores disponibles.\nPara poder obtener la pendiente vamos a usar la función ee.Terrain.slope la cual calcula la pendiente en los DEMs. Como la función obtiene la pendiente haciendo uso de los vecinos de cada pixel. Entonces, cuando el pixel no tenga sus 4 vecinos por aristas, no podrá obtener el valor de la pendiente en dicho pixel. Esto ocasiona que en los bordes de las imágenes no se pueda calcular un valor.\nLa función ee.Terrain.slope sólo funciona en imágenes, por tal motivo es necesario envolver la función para aplicarla a cada elemento de la nuestra colección de Imagenes (ImageCollection) y mapear dicha función usando el metodo .map\n\n///Calculate the slope of the country Geometry\nvar slope_wrap = function(image){\n    var slope = ee.Terrain.slope(image).clip(country).rename('Slope');\n    return slope;\n  };\nEsta función toma una imagen y calcula la pendiente en dicha imagen, despues se queda con las partes de la imagen que se encuentran dentro de la geometría de country y cambia el nombre de la banda.\nAplicamos la función a nuestra colección de imágenes y se almacena en la variable slope_country_in.\nvar slope_country_in= dataset.filterBounds(country).select('DEM').map(slope_wrap);\nAquí se hace notar, que antes de aplicar la función ‘slope_wrap’, lo que se hace es tomar las imágenes que tocan a la geometría de country (polígono) y seleccionar la banda DEM. Esto evita hacer cálculos inecesarios y en ciertas ocasiones puede disminuir los tiempos de cómputo para obtener el resultado final.\nUna vez obtenido la imagen de las pendientes, entonces podemos filtrarlas usando los valores de la pendiente. Creamos un filtor por cada tipo de pendiente.\nvar filter_vgood= function(image){\n  return image.updateMask(image.lte(3.15)).rename('vgood');\n};\n\nvar filter_good= function(image){\n  return image.updateMask(image.gt(3.15).and(image.lte(7.87))).rename('good');\n};\n\nvar filter_poor= function(image){\n  return image.updateMask(image.gt(7.87).and(image.lte(14.87))).rename('regular');\n};\n\nvar filter_vpoor= function(image){\n  return image.updateMask(image.gt(14.88).and(image.lte(44.6))).rename('poor');\n};\n\nvar filter_vpoor= function(image){\n  return image.updateMask(image.gt(44.6).and(image.lte(90))).rename('vpoor');\n};\nA continuacion vamos a definir los parámetros de distintas visualizaciones que podriamos hacer. Aunque no se utilizan todas en el scrip final.\n\nvar elevationVis = {\n  min: 0.0,\n  max: 3000.0,\n  palette: ['0000ff','00ffff','ffff00','ff0000','ffffff'],\n};\n\nvar slopeVgood = {\n  min: 0,\n  max: 3.15,\n  palette: palette_vgood,\n  opacity:0.7\n};\n\nvar slopegood = {\n  min: 3.16,\n  max: 7.87,\n  palette: palette_good,\n  opacity:0.7\n};\n\nvar sloperegular = {\n  min: 7.88,\n  max: 14.87,\n  palette: palette_poor,\n  opacity:0.7\n};\n\nvar slopepoor = {\n  min: 14.87,\n  max: 44.6,\n  palette: palette_vpoor,\n  opacity:0.7\n};\n\n\nvar slopeVpoor = {\n  min: 44.87,\n  max: 90,\n  palette: palette_vpoor,\n  opacity:0.7\n};\nVamos hacer una función para que haga todo cada vez que lo necesitemos, la función usa como parametro el string del nombre del pais que deseamos visualizar. Se obtiene el poligono del pais y se filtran las imagenes para solo tener las imagenes que se encuentran dentro del la regiön de interes. Se almacenan dentro de de la variable slope_country_in.\nUtilizando la coleccion de imagenes filtradan se enmascaran los pixeles de las imágenes usando los filtros antes definidos y se almacenan en las variables slope_good_mask_in, slope_vgood_mask_in, slope_poor_mask_iny slope_vpoor_mask_in. Se hacen las respectivas capas para cada una de las direfentes tipos de pendienter las cuales usan las escalas de colores que se definieron con anterioridad. Estas capas junto con una capa del poligono del país seleccionado se añaden al mapa y se centran en el poligono del pais selecionado haciendo un sum de \\(5\\).\nfunction redraw(name_country){\n  print('Pais:',name_country);\n  // se seleccionan el pais y las imagenes dentro del pais\n  country = worldcountries.filter(ee.Filter.eq('country_na',  name_country));\n  var slope_country_in= dataset.filterBounds(country).select('DEM').map(slope_wrap);\n  /// se enmascaran los pixeles de las imagenes con los distintos tipos de pendientes\n  var slope_good_mask_in = slope_country_in.map(filter_good);\n  var slope_vgood_mask_in = slope_country_in.map(filter_vgood);\n  var slope_poor_mask_in = slope_country_in.map(filter_poor);\n  var slope_vpoor_mask_in = slope_country_in.map(filter_vpoor);\n  /// se definen las capas\n  lay_pais = ui.Map.Layer(country,{color:'gray', opacity:0.8}, 'Pais');\n  lay_vgood = ui.Map.Layer( slope_vgood_mask_in, slopeVgood, 'Very Good slope' );\n  lay_good = ui.Map.Layer( slope_good_mask_in, slopegood, 'Good slope' );\n  lay_poor = ui.Map.Layer( slope_poor_mask_in, slopepoor, 'Poor slope' );\n  lay_vpoor = ui.Map.Layer( slope_vpoor_mask_in, slopeVpoor , 'Very Poor slope' );  \n  //// añade capas al mapa interactivo\n  Map.centerObject(country, 5);\n  Map.layers().reset();\n  Map.layers().set(0, lay_pais);\n  Map.layers().set(1, lay_vgood);\n  Map.layers().set(2, lay_good);\n  Map.layers().set(3, lay_poor);\n  Map.layers().set(4, lay_vpoor);\n    \n}\nYa hicimos todo pero os falta hacer a el mapa interactivo, para esto vamos a obtener la lista de paises que se desean seleccionar, en este caso vamos a utilizar la lista completa de paises disponibles.\nvar names = worldcountries.aggregate_array('country_na').sort();\nLo que pedimos es que a partir del conjunto de datos worldcountries agregue de forma ordenada los datos que se encuentra en el campo country_na.\nVamos a añadir un boton para seleccionar el pais usando ui.Select donde las cosas a seleccionar son la lista de paises las cuales al ser seleccionados lo pasaran como parámetro a la función redraw. Activando la ejecuciön de la funcion, generando las capas de las pendientes y la capa del pais, las cuales se añaden al mapa. Todo se realiza dentro de la funciön redraw.\nvar select = ui.Select({items: names.getInfo(), onChange: redraw });\nselect.setPlaceholder('Select country'); \nSolo nos falta agregar el boton al mapa. Esto se realiza en la siguiente linea de codigo donde al mapa se le añade el objeto selectel cual contiene el boton.\nMap.add(select);\nY nos queda de la siguiente forma:\n\n\n\nPendiente en mexico\n\n\nSe puede mejorar la visualización recortando las imágenes a sólo la región determinada por el polígono del país. Pero eso lo dejamos como ejercicio al lector.\nEl scrip completo se puede ejecutar desde GEE en el siguiente link y para ver sólo el resultado lo podemos hacer atravez de este link"
  },
  {
    "objectID": "posts/NVDI/index.html",
    "href": "posts/NVDI/index.html",
    "title": "NDVI",
    "section": "",
    "text": "Cálculo de NDVI\nVamos a calcular un índice muy utilizado para hacer el cálculo de la vegentación en los suelos este es llamado Normalized Difference Vegetation Index (NDVI). Para tal motivo vamos a utilizar el conjunto de imágenes satelitales proporcionado por la agencia espacial europea. Un cierto conjunto de imágenes del programa copernicus y de las misiones Sentinel esta disponible en GEE.\nPara obtener el NDVI se debe aplicar la siguiente función \\[\nNDVI = \\frac{NIR - rojo}{NIR +  rojo}\n\\]\ndonde \\(NIR\\) es la banda que corresponde a la frecuencia cercana al infra rojo (Near-infrared) y rojo es la banda correspondiente a la frecuencia que corresponde al color rojo.\nVamos a concentrarnos en las imágenes que toquen a mexico por tal motivo tomamos el polígono de México como lo hicimos en la introducción a GEE\nVamos a calcular un índice muy utilizado para hacer un cálculo de vegentación este es llamado Normalized Difference Vegetation Index (NDVI). Para tal motivo vamos a utilizar el conjunto de imágenes satelitales proporcionado por la agencia espacial europea. Un cierto conjunto de imágenes del programa copernicus y de las misiones Sentinel esta disponible en GEE.\nVamos a concentrarnos en las imágenes que toquen a mexico por tal motivo tomamos el polígono de México como lo hicimos en la introducción a GEE\nvar worldcountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\nvar country = worldcountries.filter(ee.Filter.eq('country_na', 'Mexico'));\nEn este caso vamos a tomar la colección COPERNICUS/S2_SR en general en el catalogo de GEE en la sección de cada colección podemos ver una descripción general, un pequeño ejemplo y las bandas de cada imagen.\nEn las siguientes lineas de código se selecciona la colección y se filtra a las imágenes que toquen al polygono que esta en la variable country y se filtra en un rango de fechas.\nvar S2_SR = ee.ImageCollection('COPERNICUS/S2_SR')\n  .filterBounds(country)\n  .filterDate('2018-01-01', '2019-01-01');\nPara obtener el NDVI vamos a usar las bandas B4 y B8\nvar nirBand = 'B8';\nvar redBand = 'B4';\nVamos a tomar la primera imagen de la collección de imágenes, para hacer esto el objeto ImageCollection tiene una función llamada first. Se calcula el NDVI para dicha imagen como prueba se guarda eu una variable, podemos observar que en la imagen ndvi_fitenemos una nueva banda la cual no se encuentra en la primera imagen de la collección.\nprint(S2_SR.first());\nvar ndvi_fi = S2_SR.first().normalizedDifference([nirBand, redBand]).rename('NVDI');\nprint(ndvi_fi);\nVamos a visualizar lo que tenemos hasta ahora\nvar NDVIpalette = ['FFFFFF', 'CE7E45', 'DF923D', 'F1B555', 'FCD163',\n'99B718', '74A901', '66A000', '529400', '3E8601', '207401', '056201',\n'004C00', '023B01', '012E01', '011D01', '011301'];\nMap.addLayer(country);\nMap.addLayer(ndvi_fi, {palette: NDVIpalette}, 'NVDI de Sentinel');\nComo podemos ver en la imagen Figure 1 tenemos una pequeña parte del territorio con el calculo de NDVI, esto es debido a que la primera imagen de la colleccion no cubre todo el territorio de la República Mexicana, por tal motivo es necesario obtener el NDVI a todo el conjunto de imágenes en la collección que ya filtramos.\n\n\n\n\n\n\nFigure 1: NDVI una parte de México\n\n\n\nPara hacer esto lo que se hace lo mismo para todas las imágenes dentro de la colección. En GEE lo hacemos mediante funciones, las funciones deben de tener como parámetro los elementos de la colección ya sea de Feature o de Image y hacer lo necesario dentro de la función. En este caso a cada imagen utiliza la función normalizeDifference a las bandas B4 y B8 función y aplicar esta función a cada elemento de la colección\nPara declarar la función se hace usando la siguiente estructura\nvar nombre = function(parametro){\n  ///Cuerpo de la función \n\n  var parametro_interno = 5\n  return parametro + parametro_interno \n\n}\nUsando la estructura anterior se adapta para nuestro objetivo, y se regresa la imagen con la nueva banda calculada.\nvar addNDVI = function(image) {\n  var ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI');\n  return image.addBands(ndvi);\n};\nEn la variable addNDVIse encuentra la función y vamos aplicar la función a los elementos de la colección. Para esto la clase ‘ImageCollection’ tiene un método implementado ‘.map’.\nvar S2_NDVI = S2_SR.map(addNDVI);\nY usando los mismos parámetros de visualización desplegamos las imágenes en nuestro mapa\nvar S2_NDVI = S2_SR.map(addNDVI);\nMap.addLayer(S2_NDVI.select('NDVI'), {palette: NDVIpalette}, 'NVDI de Sentinel');\nY el resultado lo podemos ver en la imagen\n\n\n\nNDVI Republica mMxicana\n\n\nSe recomienda intentar las siguientes mejoras como ejercicio.\nCosas para que se vea bien.\n\nMostrar sólo el pais.\nEsta borroso\n\nvar worldcountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n\nvar country = worldcountries.filter(ee.Filter.eq('country_na', 'Mexico'));\nvar S2_SR = ee.ImageCollection('COPERNICUS/S2_SR')\n  .filterBounds(country)\n  .filterDate('2018-01-01', '2019-01-01');\n\nvar nirBand = 'B8';\nvar redBand = 'B4';\n\nprint(S2_SR.first());\nvar ndvi_fi = S2_SR.first().normalizedDifference([nirBand, redBand]).rename('NVDI');\n\n\nprint(ndvi_fi);\n\n\n\nvar NDVIpalette = ['FFFFFF', 'CE7E45', 'DF923D', 'F1B555', 'FCD163',\n'99B718', '74A901', '66A000', '529400', '3E8601', '207401', '056201',\n'004C00', '023B01', '012E01', '011D01', '011301'];\nMap.addLayer(country);\n//Map.addLayer(ndvi_fi, {palette: NDVIpalette}, 'NVDI de Sentinel');\n\nvar addNDVI = function(image) {\n  var ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI').clip(country);\n  return image.addBands(ndvi);\n};\n///////\n\nvar S2_NDVI = S2_SR.map(addNDVI);\nMap.addLayer(S2_NDVI.select('NDVI'), {palette: NDVIpalette}, 'NVDI de Sentinel');"
  },
  {
    "objectID": "posts/Introduccion/index.html",
    "href": "posts/Introduccion/index.html",
    "title": "Introducción a Google Earth Engine",
    "section": "",
    "text": "Este blog lo utilizaremos como plataforma para poder hacer un curso de Google Earth Engine y este es el primer post de dicho blog.\n\n\nGoogle earth engine (GEE) es una servicio de procesamiento geoespacial en linea el cual tiene la capacidad de hacer procesamientos a gran escala. Esto nos ayuda a procesar grandes cantidades de datos geoespaciales (que muchos se encuentran dentro de GEE).\nGEE nos permite usar catalogos públicos de imágenes satelitales y generar servicios interactivos (mapas).\nGEE esta pensado para su uso usando el sitio https://code.earthengine.google.com/, para poder hacer uso del mismo es necesario darse de alta en el servicio a traves de una cuente de Google.\n\n\n\nVamos a utilizar como principal herramienta el editor de código de GEE.\n\n\n\nConsola de GEE\n\n\nDentro de esta consola se tiene las siguientes partes\n\nCode Editor: dentro de esta area se desarrolla el código en GEE usando JavaScript\n\n\n\n\nEditor código GEE\n\n\n\nConsole: Muestra la salidas que se piden dentro del código ejecutado. Si hay errores en el código ejecutado en esta sección se mostrarán los mensajes de error corespondientes.\n\n\n\n\nConsola GEE\n\n\n\nInspector: En esta parte se pueden inspeccionar los elementops dentro de los mapas generados.\n\n\n\n\nInspector de elementos de GEE\n\n\n\nTask: El manejador de tareas nos sirve para monitoriar las distintas tareas solicitadas dentro de GEE como puede ser la descarga o subida de imágenes.\n\n\n\n\nManejador de tareas GEE\n\n\n\nScripts Esta parte funciona como un navegador de archivos para los scripts propios y otros a los cuales se tiene acceso como pueden ser los compartidos por otros usuarios.\n\n\n\n\nNavegador Scripts\n\n\n\nDocs: Aquí podemos encontrar muchos ejemplos distintos de como se utiliza GEE, lo cuales son compartidos por los desarrolladores de la plataforma. \nAssets: En esta sección se encuentran objetos que fueron subidos por el usuario para ayudar en la generación de mapas. Los distintos objetos pueden ser imágenes rasters u objetos geométricos lo cualess pueden estar dentro de un archivo ‘.shp’. \n\n\n\n\nEl lenguaje de uso nativo de GEE es JavaScript, aunque se ha desarrollado una API (Application Programming Interface) para python esta también hace uso de scripts escritos en JavaScript. Vamos a explicar los básicos en JavaScript y a partir de éstos se puede hacer una transición hacia códigos en Python de forma más sencilla.\nAunque se hace uso de JavaScript este no es un curso de JavaScript por tal motivo vamos a explicar las cosas necesarias para hacer cosas dentro de GEE.\n\n\n\nComo es regular en los lenguajes de programación vamos hacer un script para imprimir hola mundo.\nDentro de la sección de editor de código escribimos lo siguiente:\nprint('Hola Mundo')\npara hacer la ejecución de todo nuestro script se oprime el boton ‘Run’\n\n\n\nEjecutar el código RUN\n\n\nEn sección de la consola aparece la leyenda ‘Hola Mundo’. Lo primero que podemos observar es el uso de la función ‘print()’ nos permite imrpimir cadenas de caracteres. Esta función también nos permite imprimir distintos de estructuras de datos como son los metadatos de imágenes satelitáles o bien datos especificos como valores numéricos.\nEn JavaScripts en GEE tenemos distintos tipos de estructuras de datos como ‘Image’, ‘Feature’, ‘Dictionary’, ‘List’, ‘Array’, ‘Date’, ‘Number’ y ‘String’. En GEE las principales estructuras son ‘Image’ y ‘Feature’, la estructura ‘Image’ es la estructura en donde se almacenan las imagenes, la imágenes pueden tener distintas bandas, como son la mayoría de las imágenes raster satelitales. La estructura ‘Feature’ en GEE en el fondo es un GeoJSON, el cual es un objeto que debe de tener una propiedad ‘Geometry’, aunque esta puede ser ‘Null’, el uso común de la estructura ‘Feature’ nos sirve para asociar una propiedad a los objetos geométricos.\nAhora vamos a obtener cosas en un mapa, en el editor de código se escribe el siguiente script.\nvar paises = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n//print(paises)\nvar filtromexico  = ee.Filter.eq('country_na', 'Mexico');\nvar paismexico = paises.filter(filtromexico)\n//print(paismexico)\nMap.addLayer(paismexico);\nMap.centerObject(paismexico, 4);\n//Map.setCenter(-99.221440, 19.291990,  4);\nGEE nos permite tener acceso a un extenso conjunto de datos en este caso vamos a utilizar la colección de datos ‘USDOS/LSIB_SIMPLE/2017’ la cual son los polígonos a gran escala de los paises de acuerdo al departamento de estado de EUA. ee.FeatureCollection es una estructura de datos que nos permite hacer el manejo de colecciones de ee.Features (‘Features’) de igual forma existe la estructura de datos ‘ee.ImageCollection’.\nLo primero que vemos dentro del código es la forma para declarar variables dentro de JavaScript este usa la palabra var para decir que lo siguiente sera una variable. En la variable paises se encuentra la colleccion de los políogonos de paises. Al ser una coleccion vamos a quedarnos sólo con el país Mexico. En la variable filtromexico contiene un filtro el cual filtrara usando el campo ‘country_na’ a los elementos que cuyo campo tengan la cadena ‘Mexico’.\nEn la variable paismexico tenemos el resultado de aplicar el filtro ‘filtromexico’ en la colección paises.\nLas siguentes dos lineas en el código añaden al mapa el polígono que se encuentra en la variable paismexico y pone el mapa centrado en la variable con un zoom de 4.\nEn el código podemos observar la forma de evitar que se ejecuten ciertas lineas de código // nos sirve para hacer comentarios para poder explicar el código o bien para evitar que se ejecuten ciertas lineas. Esto es de particular relevancia cuando estamos experimentando o haciendo la limpieza del código.\nPodemos ejecutar el código que acabamos de crear presionando el boton ‘run’, una vez ejecutado podemos ver en el mapa de México\n\n\n\nMostramos México\n\n\nVamos a añadir algunas lineas más de código\nvar worldcountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n//print(worldcountries)\nvar filterCountry = ee.Filter.eq('country_na', 'Mexico');\n//var filterCountry = ee.Filter.inList('country_na', ['Mexico', 'Guatemala']);\nvar country = worldcountries.filter(filterCountry);\n\nMap.addLayer(country, {color: 'yellow'}, 'Paises');\nMap.centerObject(country, 4);\n\n\nvar collection  = ee.ImageCollection('COPERNICUS/S5P/OFFL/L3_NO2')\n  .select('NO2_column_number_density');\n//print(collection.first())\n\n/// FILTROS PARA SELECIONAR LAS IMAGENES QUE SE DESEAN \n\n\nvar filter19 = ee.Filter.date('2019-10-01', '2019-10-02');\n\n\nvar no2_19 = collection.filter(filter19).mean().multiply(1e6).clip(country);\n\n//print('imagen 2019:',  no2_19);\nvar vizParams = {\n  min: 0,\n  max: 200,\n  palette: ['black', 'purple', 'green', 'red']\n};\n\n\nMap.addLayer(no2_19, vizParams, 'no2_19');\nOtro de los objetos importantes dentro de GEE son las colecciones de imágenes, en una collección de se encuentran las imágenes en donde todas comparten ciertas propiedades comunes como son su sistema de referencia, el algoritmo con el que se hizo, etc.\nTomar la colección de imagenes completa en general no es necesario, por lo general o se selecciona una o se obtiene sus agregados dependiendo de la banda. Las imágenes satelitales en general contienen muchas bandas de los distintos sensores o imágenes generadas a través de algoritmos usando los datos de sensores satelitales. Como no es necesario hacer uso de todas las bandas, ni todas las imágenes es necesario tener la capacidad de seleccionar lo que consideremos de nuestro interes. En GEE existen objetos que nos ayudan a seleccionar, estos objetos son los filtros [ee.Filter] (https://developers.google.com/earth-engine/apidocs/ee-filter), estos filtros pueden filtrar campos en especifico.\nEn la siguiente linea se hace un objeto de tipo ee.Filter que filtra las imágenes de la coleccion de imágenes usando las fechas, en las siguentes lineas de código en la variable no2_19 se almacenan los resultados de usar el filtro filter19 y obtener el promedio de todas las imágenes, se multiplica por el escalar \\(1\\times10^6\\) y se toman solo el area que concide con el poligono en la variable country. Sólo para entender se imprime en la consola y observar que lo que obtenemos es realmente una imagen.\nPara poder hacer una visualización de las imágenes, es necesario dar un conjunto de parámetros al objeto donde esta nuestro mapa Map. En el caso anterior donde se muestra el polígono en el mapa no se añade ningún color, pero en este caso se cambio a amarillo y se añade el nombre de la capa. Para hacer la visualización de la imagenen es necesario conocer sus valores máximos y mínimos, adicionammente se le da un conjunto de colores para colorear la imagen, estos colores nos muestren una diferencia entre los valores de la imagen y al usar el color amarillo de fondo se observa con mayor claridad los lugares donde la imagen no tiene datos.\nEl resultado lo vamos a poder ver en el mapa\n\n\n\n\\(NO_2\\) en la republica mexicana en un día"
  },
  {
    "objectID": "posts/Introduccion/index.html#introducción",
    "href": "posts/Introduccion/index.html#introducción",
    "title": "Introducción a Google Earth Engine",
    "section": "",
    "text": "Google earth engine (GEE) es una servicio de procesamiento geoespacial en linea el cual tiene la capacidad de hacer procesamientos a gran escala. Esto nos ayuda a procesar grandes cantidades de datos geoespaciales (que muchos se encuentran dentro de GEE).\nGEE nos permite usar catalogos públicos de imágenes satelitales y generar servicios interactivos (mapas).\nGEE esta pensado para su uso usando el sitio https://code.earthengine.google.com/, para poder hacer uso del mismo es necesario darse de alta en el servicio a traves de una cuente de Google."
  },
  {
    "objectID": "posts/Introduccion/index.html#entendiendo-gee",
    "href": "posts/Introduccion/index.html#entendiendo-gee",
    "title": "Introducción a Google Earth Engine",
    "section": "",
    "text": "Vamos a utilizar como principal herramienta el editor de código de GEE.\n\n\n\nConsola de GEE\n\n\nDentro de esta consola se tiene las siguientes partes\n\nCode Editor: dentro de esta area se desarrolla el código en GEE usando JavaScript\n\n\n\n\nEditor código GEE\n\n\n\nConsole: Muestra la salidas que se piden dentro del código ejecutado. Si hay errores en el código ejecutado en esta sección se mostrarán los mensajes de error corespondientes.\n\n\n\n\nConsola GEE\n\n\n\nInspector: En esta parte se pueden inspeccionar los elementops dentro de los mapas generados.\n\n\n\n\nInspector de elementos de GEE\n\n\n\nTask: El manejador de tareas nos sirve para monitoriar las distintas tareas solicitadas dentro de GEE como puede ser la descarga o subida de imágenes.\n\n\n\n\nManejador de tareas GEE\n\n\n\nScripts Esta parte funciona como un navegador de archivos para los scripts propios y otros a los cuales se tiene acceso como pueden ser los compartidos por otros usuarios.\n\n\n\n\nNavegador Scripts\n\n\n\nDocs: Aquí podemos encontrar muchos ejemplos distintos de como se utiliza GEE, lo cuales son compartidos por los desarrolladores de la plataforma. \nAssets: En esta sección se encuentran objetos que fueron subidos por el usuario para ayudar en la generación de mapas. Los distintos objetos pueden ser imágenes rasters u objetos geométricos lo cualess pueden estar dentro de un archivo ‘.shp’."
  },
  {
    "objectID": "posts/Introduccion/index.html#entendiendo-un-poco-más",
    "href": "posts/Introduccion/index.html#entendiendo-un-poco-más",
    "title": "Introducción a Google Earth Engine",
    "section": "",
    "text": "El lenguaje de uso nativo de GEE es JavaScript, aunque se ha desarrollado una API (Application Programming Interface) para python esta también hace uso de scripts escritos en JavaScript. Vamos a explicar los básicos en JavaScript y a partir de éstos se puede hacer una transición hacia códigos en Python de forma más sencilla.\nAunque se hace uso de JavaScript este no es un curso de JavaScript por tal motivo vamos a explicar las cosas necesarias para hacer cosas dentro de GEE."
  },
  {
    "objectID": "posts/Introduccion/index.html#hola-mundo",
    "href": "posts/Introduccion/index.html#hola-mundo",
    "title": "Introducción a Google Earth Engine",
    "section": "",
    "text": "Como es regular en los lenguajes de programación vamos hacer un script para imprimir hola mundo.\nDentro de la sección de editor de código escribimos lo siguiente:\nprint('Hola Mundo')\npara hacer la ejecución de todo nuestro script se oprime el boton ‘Run’\n\n\n\nEjecutar el código RUN\n\n\nEn sección de la consola aparece la leyenda ‘Hola Mundo’. Lo primero que podemos observar es el uso de la función ‘print()’ nos permite imrpimir cadenas de caracteres. Esta función también nos permite imprimir distintos de estructuras de datos como son los metadatos de imágenes satelitáles o bien datos especificos como valores numéricos.\nEn JavaScripts en GEE tenemos distintos tipos de estructuras de datos como ‘Image’, ‘Feature’, ‘Dictionary’, ‘List’, ‘Array’, ‘Date’, ‘Number’ y ‘String’. En GEE las principales estructuras son ‘Image’ y ‘Feature’, la estructura ‘Image’ es la estructura en donde se almacenan las imagenes, la imágenes pueden tener distintas bandas, como son la mayoría de las imágenes raster satelitales. La estructura ‘Feature’ en GEE en el fondo es un GeoJSON, el cual es un objeto que debe de tener una propiedad ‘Geometry’, aunque esta puede ser ‘Null’, el uso común de la estructura ‘Feature’ nos sirve para asociar una propiedad a los objetos geométricos.\nAhora vamos a obtener cosas en un mapa, en el editor de código se escribe el siguiente script.\nvar paises = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n//print(paises)\nvar filtromexico  = ee.Filter.eq('country_na', 'Mexico');\nvar paismexico = paises.filter(filtromexico)\n//print(paismexico)\nMap.addLayer(paismexico);\nMap.centerObject(paismexico, 4);\n//Map.setCenter(-99.221440, 19.291990,  4);\nGEE nos permite tener acceso a un extenso conjunto de datos en este caso vamos a utilizar la colección de datos ‘USDOS/LSIB_SIMPLE/2017’ la cual son los polígonos a gran escala de los paises de acuerdo al departamento de estado de EUA. ee.FeatureCollection es una estructura de datos que nos permite hacer el manejo de colecciones de ee.Features (‘Features’) de igual forma existe la estructura de datos ‘ee.ImageCollection’.\nLo primero que vemos dentro del código es la forma para declarar variables dentro de JavaScript este usa la palabra var para decir que lo siguiente sera una variable. En la variable paises se encuentra la colleccion de los políogonos de paises. Al ser una coleccion vamos a quedarnos sólo con el país Mexico. En la variable filtromexico contiene un filtro el cual filtrara usando el campo ‘country_na’ a los elementos que cuyo campo tengan la cadena ‘Mexico’.\nEn la variable paismexico tenemos el resultado de aplicar el filtro ‘filtromexico’ en la colección paises.\nLas siguentes dos lineas en el código añaden al mapa el polígono que se encuentra en la variable paismexico y pone el mapa centrado en la variable con un zoom de 4.\nEn el código podemos observar la forma de evitar que se ejecuten ciertas lineas de código // nos sirve para hacer comentarios para poder explicar el código o bien para evitar que se ejecuten ciertas lineas. Esto es de particular relevancia cuando estamos experimentando o haciendo la limpieza del código.\nPodemos ejecutar el código que acabamos de crear presionando el boton ‘run’, una vez ejecutado podemos ver en el mapa de México\n\n\n\nMostramos México\n\n\nVamos a añadir algunas lineas más de código\nvar worldcountries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017');\n//print(worldcountries)\nvar filterCountry = ee.Filter.eq('country_na', 'Mexico');\n//var filterCountry = ee.Filter.inList('country_na', ['Mexico', 'Guatemala']);\nvar country = worldcountries.filter(filterCountry);\n\nMap.addLayer(country, {color: 'yellow'}, 'Paises');\nMap.centerObject(country, 4);\n\n\nvar collection  = ee.ImageCollection('COPERNICUS/S5P/OFFL/L3_NO2')\n  .select('NO2_column_number_density');\n//print(collection.first())\n\n/// FILTROS PARA SELECIONAR LAS IMAGENES QUE SE DESEAN \n\n\nvar filter19 = ee.Filter.date('2019-10-01', '2019-10-02');\n\n\nvar no2_19 = collection.filter(filter19).mean().multiply(1e6).clip(country);\n\n//print('imagen 2019:',  no2_19);\nvar vizParams = {\n  min: 0,\n  max: 200,\n  palette: ['black', 'purple', 'green', 'red']\n};\n\n\nMap.addLayer(no2_19, vizParams, 'no2_19');\nOtro de los objetos importantes dentro de GEE son las colecciones de imágenes, en una collección de se encuentran las imágenes en donde todas comparten ciertas propiedades comunes como son su sistema de referencia, el algoritmo con el que se hizo, etc.\nTomar la colección de imagenes completa en general no es necesario, por lo general o se selecciona una o se obtiene sus agregados dependiendo de la banda. Las imágenes satelitales en general contienen muchas bandas de los distintos sensores o imágenes generadas a través de algoritmos usando los datos de sensores satelitales. Como no es necesario hacer uso de todas las bandas, ni todas las imágenes es necesario tener la capacidad de seleccionar lo que consideremos de nuestro interes. En GEE existen objetos que nos ayudan a seleccionar, estos objetos son los filtros [ee.Filter] (https://developers.google.com/earth-engine/apidocs/ee-filter), estos filtros pueden filtrar campos en especifico.\nEn la siguiente linea se hace un objeto de tipo ee.Filter que filtra las imágenes de la coleccion de imágenes usando las fechas, en las siguentes lineas de código en la variable no2_19 se almacenan los resultados de usar el filtro filter19 y obtener el promedio de todas las imágenes, se multiplica por el escalar \\(1\\times10^6\\) y se toman solo el area que concide con el poligono en la variable country. Sólo para entender se imprime en la consola y observar que lo que obtenemos es realmente una imagen.\nPara poder hacer una visualización de las imágenes, es necesario dar un conjunto de parámetros al objeto donde esta nuestro mapa Map. En el caso anterior donde se muestra el polígono en el mapa no se añade ningún color, pero en este caso se cambio a amarillo y se añade el nombre de la capa. Para hacer la visualización de la imagenen es necesario conocer sus valores máximos y mínimos, adicionammente se le da un conjunto de colores para colorear la imagen, estos colores nos muestren una diferencia entre los valores de la imagen y al usar el color amarillo de fondo se observa con mayor claridad los lugares donde la imagen no tiene datos.\nEl resultado lo vamos a poder ver en el mapa\n\n\n\n\\(NO_2\\) en la republica mexicana en un día"
  },
  {
    "objectID": "posts/Modelo/Modelo.html",
    "href": "posts/Modelo/Modelo.html",
    "title": "Hacer modelos en GEE",
    "section": "",
    "text": "Google Earth Engine (GEE) es una herramienta muy útil, dentro de la cuál se pueden generar modelos matemáticos para las distintas problemáticas que se deseen visualizar dentro de GEE. Sin embargo, el desarrollo no se debe limitar al uso exclusivo de GEE pues esto nos restringiría al uso de otras herramientas desarrolladas por distintos individuos o grupos de trabajo. Bajo esta primicia, en este pequeño tutorial vamos a mostrar como se podemos exportar un modelo creado en otras plataformas y poder exportarlo a GEE.\nEn este sentido vamos a usar la plataforma GEE para exportar modelos y poder hacer la visualización de los resultados en GEE."
  },
  {
    "objectID": "posts/Modelo/Modelo.html#colección-de-imágenes",
    "href": "posts/Modelo/Modelo.html#colección-de-imágenes",
    "title": "Hacer modelos en GEE",
    "section": "Colección de Imágenes",
    "text": "Colección de Imágenes\nPara hacer uso de la colección de imágenes se hace usando la siguiente linea\nvar AOD_MODIS_fix =  ee.ImageCollection(\"MODIS/006/MCD19A2_GRANULES\");\nLa colección de imágenes contiene las imágenes disponibles del conjunto de datos, lo que normalmente son muchas imágenes disponibles, dentro de las cuales la mayoría no vamos a utilizar, para esto los objetos ‘ee.ImageCollection’ tienen métodos que nos ayudan a poder filtrar las imágenes dentro de la colección de imágenes.\nLa siguiente linea de código nos filtra la colección sólo con las imágenes que se tomaron del ‘2005-01-01’ al ‘2016-01-01’.\nvar AOD_MODIS_fix = ee.ImageCollection(\"MODIS/006/MCD19A2_GRANULES\").filterDate('2005-01-01', '2016-01-01') \nLa siguiente linea filtra las imágenes que contienen al punto cercano a CentroGeo (-99.221411, 19.29183)\nvar AOD_MODIS_fix = ee.ImageCollection(\"MODIS/006/MCD19A2_GRANULES\").filterBounds(ee.Geometry.Point(-99.221411, 19.29183))\nEstas las podemos combinar para aplicar las distintas acciones de forma concatenada, es decir, podemos filtrar primero por fecha y después al resultado filtrar las imágenes que intersectan al punto dentro de la misma ejecución, como se muestra a continuación\nvar AOD_MODIS_fix = ee.ImageCollection(\"MODIS/006/MCD19A2_GRANULES\")\n.filterDate('2005-01-01', '2016-01-01') \n.filterBounds(ee.Geometry.Point(-99.221411, 19.29183));\nEste tipo de acciones las podemos implementar no sólo con filtrados sino con distintas acciones disponibles en GEE."
  },
  {
    "objectID": "posts/Modelo/Modelo.html#subir-datos-a-gee",
    "href": "posts/Modelo/Modelo.html#subir-datos-a-gee",
    "title": "Hacer modelos en GEE",
    "section": "Subir datos a GEE",
    "text": "Subir datos a GEE\nEn la pestaña ‘Assets’ dentro del editor de código de GEE (panel superior izquierdo) podemos añadir elementos para hacer uso de los mismos como se muestra en la imagen.\n.\nLos elementos que podemos añadir a GEE son imágenes (.tif, tiff), tablas en archivos shape (.shp, .shx, .dbf, .prj o .zip) o archivos csv (.csv). También podemos agregar colecciones de imágenes o folders que contengan este tipo de archivos. Los elementos que subimos a GEE se almacenan en proyectos en la nube de Google, esto hace que estén accesibles desde GEE cada vez que sea necesario. Al estar dentro de la nube de Google las políticas de acceso a los mismos son las de la Nube de Google y también son accesibles desde las API de Google cloud como CLI.\nPara hacer uso de estos elementos dentro del editor de código de GEE se pueden insertar haciendo uso de la interfaz gráfica como se muestra en la imagen @fig:ins_elem. Los elementos añadidos se insertaran al inicio de nuestro código como un preámbulo llamado Imports, se pueden editar los nombres para que los nombres de las variables donde se almacenan sean de acuerdo a las políticas del desarrollador.\n\n\n\ninsertar elementos\n\n\nSi se desea compartir los elementos que se encuentran en el preámbulo Imports se hace click en el botón azul a lado de Imports esto abrira una ventana la cual contendra todos los elementos que se encuentran dentro de el preámbulo Imports. Los elementos también pueden ser añadidos al código simplemente copiando y pegando. Se puede eliminar los elementos importados usando un botón de basura que se encuentra en el margen izquierdo cuando se pasa a lado del elemento insertado.\n\n\n\ncopiar elementos\n\n\nPara añadirlo de forma directa al código, se hace a través de insertar el nombre del elemento y declararlo como el objeto que es. En el caso de una imagen se utiliza ee.Image(), para una tabla se hace con ee.FeatureCollection(), para el caso de un objeto geométrico dentro de un archivo .shp se hace como si fuese un tabla con ee.FeatureCollection(), y si es un conjunto de imágenes se declara con ee.ImageCollection(). El código a continuación se muestra como importamos el raster con la agregación de las vialidades extraídas de OpenStreet map (OSM) y subida a GEE en el elemento “raster_agregados_vialidades” el cual se tendrá que añadir dentro de los assets.\nvar image = ee.Image(\"raster_agregados_vialidades\");"
  },
  {
    "objectID": "posts/Modelo/Modelo.html#explicación-del-modelo",
    "href": "posts/Modelo/Modelo.html#explicación-del-modelo",
    "title": "Hacer modelos en GEE",
    "section": "Explicación del Modelo",
    "text": "Explicación del Modelo\nNuestro modelo, es una modificación al modelo utilizado por Just, haciendo uso de una fuente de información distinta de los datos meteorológicos para hacer las estimaciones, la fuente de datos a utilizar son los datos de reánalisis meteorológicos del “European Centre for Medium-Range Weather Forecasts” los cuales se encuentran disponibles dentro de GEE en el catálogo de datos. Para importar estos datos lo hacemos a traves de el siguiente código y al igual que con la colección de MODIS la filtramos por fecha, seleccionamos las bandas que vamos a utilizar y las partes de las imágenes que se encuentren dentro del “bounding box” del polígono de la zona metropolitana el cual se encuentra en la variable ZMVM_bb.\nvar land_eras_day_f = ee.ImageCollection(\"ECMWF/ERA5_LAND/HOURLY\").filter(\n            ee.Filter.date(startdate, enddate)\n        ).select([\n            'dewpoint_temperature_2m',\n            'total_evaporation',\n            'temperature_2m',\n            'total_precipitation_hourly',\n            'total_precipitation'\n        ]).filterBounds(ZMVM_bb);\nPara obtener el bounding box del polígono de la Zona Metropolitana del Valle de México (ZMVM) se hace de la siguiente forma:\nvar ZMVM_tabla = ee.FeatureCollection(\"Poligono_archivo_shape_ZMVM\");\nvar ZMVM_bb = ZMVM_tabla.geometry().bounds();\ndonde “Poligono_archivo_shape_ZMVM” es un elemento que se deberá añadir en los assets que contenga al polígono de la ZMVM. El polígono se encuentra dentro de un archivo .shp, para poder hacer uso de este elemento geométrico se hace usando .geometry() el cual extrae lo que se encuentra dentro del campo geometry de una tabla, en nuestro caso el polígono de la ZMVM. Después tomamos el cuadrado delimitador o “bounding box” usando .bounds() el cual es un método de los objetos geométricos en GEE.\nDe este conjunto de datos seleccionamos los que se encuentran en determinadas fechas y filtramos los elementos las imágenes que se intersecten con ZMVM_bb."
  },
  {
    "objectID": "posts/Modelo/Modelo.html#todos-igual",
    "href": "posts/Modelo/Modelo.html#todos-igual",
    "title": "Hacer modelos en GEE",
    "section": "Todos igual",
    "text": "Todos igual\nPor simpleza vamos a remuestrar todos los datos para que estos esten similar a los datos de MODIS.\nPara tal proposito definimos una función,\n\nvar modisProj = AOD_MODIS.first().projection();\n \nvar resample_coll = function(image){\n  return image.reproject(modisProj);\n};"
  },
  {
    "objectID": "posts/Modelo/Modelo.html#coeficientes",
    "href": "posts/Modelo/Modelo.html#coeficientes",
    "title": "Hacer modelos en GEE",
    "section": "Coeficientes",
    "text": "Coeficientes\nPor simplicidad, los coeficientes se ponen dentro de una tabla, la cual es añadida a través de los Assets. La cual tiene la siguiente forma:\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntercept\nOptical_Depth_047_z\ntemperature_2m_z\nrelative_humidity_z\ntotal_precipitation_sqrt_z\nPBLH_z\nvialidades_z\ndate\n\n\n\n\n3.9526\n0.4266\n0.2033\n-0.3986\n-0.1151\n0.0128\n2004-01-01\n1072915200\n\n\n1.1116\n0.2307\n0.2033\n-0.3986\n-0.1151\n0.0128\n2004-01-02\n1073001600\n\n\n\nsólo mostramos los primeros elementos pero la tabla deberá contener todos los días en donde es posible obtener el modelo.\n\n\n\n\n\n\nNote\n\n\n\nEsta tabla se sube usando la pestaña Assets, se resalta en particular la columna ‘system:index’, esta es la fecha en ‘Unix time’, es importante pues dentro de GEE nos sirve para poder usar el filtro de fechas (.filterDate) si el dato no se encuentra en este formato los filtros específicos de fechas no se pueden utilizar.\n\n\nLas variables a usar dentro de nuestro modelo en Equation 3 son \\(AOD_{ij}\\) es el espesor óptico de MODIS para el día \\(j\\) en la celda \\(i\\), \\(\\text{precipitation}_{ij}\\) es la precipitación y \\(\\text{temperature}_{ij}\\) la temperatura a \\(2\\) metros para el día \\(j\\) en la celda \\(i\\) las cuales se obtienen de la colección de reánalisis meteorológicos. \\(PBLH_{ij}\\) es la altura de la capa límite de mezcla. Y \\(\\text{Street density}_{i}\\) la densidad de calles en la celda \\(i\\).\nTodas la variables anteriores las podemos extraer directamente de las colecciones de imágenes que se encuentran en los datos de GEE o bien colecciones que añadimos nosotros como es el caso de \\(PBLH\\), pues esta no se encuentra directamente en GEE, es necesario descargar y añadir como colección de imágenes a GEE.\nvar PBLH_ZMVT = ee.ImageCollection(\"PBLH_data\")"
  },
  {
    "objectID": "posts/Modelo/Modelo.html#calcular-para-toda-la-colección",
    "href": "posts/Modelo/Modelo.html#calcular-para-toda-la-colección",
    "title": "Hacer modelos en GEE",
    "section": "Calcular para toda la colección",
    "text": "Calcular para toda la colección\nNos falta la variable \\(\\text{relative humidity}_{ij}\\) la cual es la humedad relativa en el día \\(j\\) en la celda \\(i\\), pero esta puede ser obtenida usando la temperatura y el punto de rocío.\n\\[\n\\frac{\\exp{(\\frac{17.625*TD}{243.04+TD})}}{\\exp(\\frac{17.625*Temp}{243.04+Temp})} \\cdot 100\n\\]\nDonde \\(Temp\\) es la temperatura y \\(TD\\) es el punto de rocío. Podemos obtener un raster de la humedad relativa aplicando usando las bandas que seleccionamos de la colección de imágenes de los datos de reanálisis con la siguiente función:\nvar relat_humed = function(image){\n  /*\n  actual_water_press = 611.21 * math.exp((17.502 * td) / (240.97 + td))\n  max_water_press = 611.21 * math.exp((17.502 * t) / (240.97 + t))\n  \n  HR=(actual_water_press/ max_water_press)*100\n  */\n  \n  var lambda_i = 243.04;\n  var beta_i = 17.625; ///17.1; //17.625;\n  \n  var dew_point =  image.select('dewpoint_temperature_2m');\n  var temp_2m =  image.select('temperature_2m');\n  var prec_total = image.select('total_precipitation');\n  var e_up  =  dew_point\n                  .multiply(beta_i);\n  var e_dow =   dew_point\n                  .add(lambda_i);\n  var e = ((e_up.divide(e_dow)).exp());\n  var e_s_up  =  temp_2m\n                  .multiply(beta_i);\n  var e_s_dow =   temp_2m\n                  .add(lambda_i);\n  var e_s   = ((e_s_up.divide(e_s_dow)).exp());\n  var rel_hum = (e.divide(e_s)).multiply(100);\n  \n  rel_hum = rel_hum .select(['dewpoint_temperature_2m']).rename(['relative_humidity']);\n  rel_hum = rel_hum\n        .addBands(temp_2m)\n        .addBands(dew_point)\n        .addBands(prec_total)\n        .set({'system:time_start':image.get('system:time_start')})\n        ;\nreturn rel_hum;\n};\n\nDefinimos una función para calcular la humedad relativa basada en el punto de rocío y la temperatura.\nLa función calcula la presión de vapor y la saturación de vapor usando las formulas respectivas.\nFinalmente se calcula la humedad relativa y se añade una nueva banda (relative_humidity) a la imagen.\n\nPara aplicar la función a las imágenes diarias se “mapea” la función a todas los elementos de la colección.\nland_eras_day_f = land_eras_day_f.map(relat_humed );"
  },
  {
    "objectID": "posts/Modelo/Modelo.html#escalas",
    "href": "posts/Modelo/Modelo.html#escalas",
    "title": "Hacer modelos en GEE",
    "section": "Escalas",
    "text": "Escalas\nUna problemática que nos podemos encontrar es que en algunas ocasiones al ajustar el modelo en R puede ser necesario escalar las variables usando z-scores para que el modelo converja. Si es necesario hacer esto entonces es necesario saber como se escalaron las variables y poder subir estos valores dentro de GEE usando una tabla. Si se escala con la función scale en R entonces nos interesan los valores “scale” y “center” donde “scale” es la desviación estándar y “center” es el promedio de los datos.\n\\[\nv_{escalada} = \\frac{v- \\mu(v)}{\\sigma(v)}\n\\]\n\\(\\mu(v)\\) es el promedio de los valores de la variable \\(v\\), \\(\\sigma(v)\\) es la desviación estándar de los valores de la variable \\(v\\) y \\(v_{escalada}\\) es la variable escalada.\nSi fue necesario escalar las variables para obtener la convergencia del modelo entonces podemos escalar los valores dentro de GEE si tenemos \\(\\mu(v)\\) y \\(\\sigma(v)\\). Por simpleza subimos una tabla la cual contiene dichos valores de forma anual.\n\n\n\nVariable\ncenter\nscale\nyear\n\n\n\n\nPM25_z\n29.48\n10.95\n2004\n\n\nOptical_Depth_047_z\n249.99\n149.17\n2004\n\n\ntemperature_2m_z\n292.50\n5.26\n2004\n\n\nrelative_humidity_z\n90.55\n3.76\n2004\n\n\ntotal_precipitation_sqrt_z\n0.02\n0.01\n2004\n\n\nPBLH_z\n450.12\n176.57\n2004\n\n\nvialidades_z\n1421.67\n1855.65\n2004\n\n\nPM25_z\n30.32\n13.84\n2005\n\n\nOptical_Depth_047_z\n266.90\n151.62\n2005\n\n\ntemperature_2m_z\n293.15\n5.34\n2005\n\n\nrelative_humidity_z\n88.98\n5.56\n2005\n\n\ntotal_precipitation_sqrt_z\n0.02\n0.02\n2005\n\n\nPBLH_z\n496.19\n216.17\n2005\n\n\nvialidades_z\n1421.67\n1855.65\n2005\n\n\n\nPara seleccionar los valores para poder escalar los datos seleccionamos los datos para un año en especifico de la siguiente forma:\nvar selected_day = '2018-04-24';\nselected_day = ee.Date(selected_day);\n\nvar scale_values = ee.FeatureCollection(\"your_scale_values_table\");\nvar all_scale_day = scale_values.filter(ee.Filter.eq('year', selected_day.get('year')));\nvar optical_scale_dic = ee.Dictionary({\n  'center': all_scale_day.filter(ee.Filter.eq('1', 'Optical_Depth_047_z')).first().get('center'),\n  'scale':all_scale_day.filter(ee.Filter.eq('1', 'Optical_Depth_047_z')).first().get('scale')\n\n});\nvar PBLH_scale_dic = ee.Dictionary({\n  'center': all_scale_day.filter(ee.Filter.eq('1', 'PBLH_z')).first().get('center'),\n  'scale':all_scale_day.filter(ee.Filter.eq('1', 'PBLH_z')).first().get('scale')\n});\nvar PM25_scale_dic = ee.Dictionary({\n  'center': all_scale_day.filter(ee.Filter.eq('1', 'PM10_z')).first().get('center'),\n  'scale':all_scale_day.filter(ee.Filter.eq('1', 'PM10_z')).first().get('scale')\n});\nvar precipitation_scale_dic = ee.Dictionary({\n  'center': all_scale_day.filter(ee.Filter.eq('1', 'total_precipitation_sqrt_z')).first().get('center'),\n  'scale':all_scale_day.filter(ee.Filter.eq('1', 'total_precipitation_sqrt_z')).first().get('scale')\n});\nvar RH_scale_dic = ee.Dictionary({\n  'center': all_scale_day.filter(ee.Filter.eq('1', 'relative_humidity_z')).first().get('center'),\n  'scale':all_scale_day.filter(ee.Filter.eq('1', 'relative_humidity_z')).first().get('scale')\n});\nvar Temp_scale_dic = ee.Dictionary({\n  'center': all_scale_day.filter(ee.Filter.eq('1', 'temperature_2m_z')).first().get('center'),\n  'scale':all_scale_day.filter(ee.Filter.eq('1', 'temperature_2m_z')).first().get('scale')\n});\nvar vialidades_scale_dic = ee.Dictionary({\n  'center': all_scale_day.filter(ee.Filter.eq('1', 'vialidades_z')).first().get('center'),\n  'scale':all_scale_day.filter(ee.Filter.eq('1', 'vialidades_z')).first().get('scale')\n});\nPara cada una de las variables tenemos un diccionario con valores center y scale para poder escalar los datos en GEE. Se hace una función especifica para las variable obtenidos de reanálisis y para los demás se hace de forma individual.\nvar z_scale_land = function(image){\n  var temp_2m = image.select('temperature_2m');\n  temp_2m= temp_2m.expression(\n      '(x - mean_x) / sd_x', {\n        'x':temp_2m ,\n        'mean_x': Temp_scale_dic.getNumber('center'),\n        'sd_x': Temp_scale_dic.getNumber('scale')\n      }\n    ).rename('temperature_2m_z');\n    \n  var rh = image.select('relative_humidity');\n  rh= rh.expression(\n      '(x - mean_x) / sd_x', {\n        'x':rh ,\n        'mean_x': RH_scale_dic.getNumber('center'),\n        'sd_x': RH_scale_dic.getNumber('scale')\n      }\n    ).rename('relative_humidity_z') ;\n    \n  var total_prec = image.select('total_precipitation');\n  total_prec= total_prec.expression(\n      '(x - mean_x) / sd_x', {\n        'x':total_prec ,\n        'mean_x': precipitation_scale_dic.getNumber('center'),\n        'sd_x': precipitation_scale_dic.getNumber('scale')\n      }\n    ).rename('total_precipitation_sqrt_z') ;\n  return temp_2m\n  .addBands(rh)\n  .addBands(total_prec)\n  .set({'system:time_start':image.get('system:time_start')});\n};\n\n\nvar optical_scale = optical_original.expression(\n      '(x - mean_x) / sd_x', {\n        'x': optical_original,\n        'mean_x': optical_scale_dic.getNumber('center'),\n        'sd_x': optical_scale_dic.getNumber('scale')\n      }\n    ).rename('Optical_Depth_047_z');\n\n\n\n\n\n\nNote\n\n\n\nCabe destacar el uso de ee.Image.expression() este método nos permite evaluar los valores en las imágenes como si fuesen fórmulas usando un string.\n\n\nUna vez escalados los valores se renombran las bandas de las imágenes, con la intención de tener un nombre que identifique que estas bandas se encuentran escaladas.\n\nUnir todo\nAhora vamos a hace uso de las bandas escaladas para poder obtener el resultado de \\(PM_{2.5}\\) tomando la combinación lineal de nuestro modelo. Aunque se puede hacer las operaciones de forma compacta en código, hacemos éstas en lineas separadas de código para que al leerlo quede de forma legible y entender los distintos pasos realizados.\n\nMultiplicamos cada banda por el respectivo coeficiente.\nGeneramos una imagen que tenga el valor constante XIntercept\nHacemos la suma de las distintas imágenes en una sola y la renombramos.\nSe re escalan los valores de \\(PM_{2.5}\\).\n\n///Multiplicar bandas coeficientes \nPBLH_day_s = PBLH_day_s.multiply(coeff_day.getNumber('PBLH_z')); \noptical_scale = optical_scale.multiply(coeff_day.getNumber('Optical_Depth_047_z'));\nvar hum_image  = day_land_eras_image_s.select('relative_humidity_z').multiply(coeff_day.getNumber('relative_humidity_z'));\nvar tem_image  = day_land_eras_image_s.select('temperature_2m_z').multiply(coeff_day.getNumber('temperature_2m_z'));\nvar prec_image = day_land_eras_image_s.select('total_precipitation_sqrt_z').multiply(coeff_day.getNumber('total_precipitation_sqrt_z'));\nvialidades_s = vialidades_s.multiply(coeff_day.getNumber('vialidades_z'));\nvar image_interc = ee.Image(coeff_day.getNumber('XIntercept')).clip(ZMVM_bb);\n\n//// Suma \nvar day_pm= ee.Image().expression(\n  'opt + pblh + viali + rh + temp + prec_sqr + Intercept',\n  {\n    'opt' :optical_scale, \n    'pblh' :PBLH_day_s, \n    'viali' :vialidades_s, \n    'Intercept': image_interc,\n    'rh':  hum_image,\n    'temp':tem_image,\n    'prec_sqr':prec_image\n     \n  }\n  ).rename('PM_scale');\n/// Rescalar a valores\nvar day_pm_re = ee.Image().expression(\n  'y*sd_x + mean_x',\n  {\n    'y': day_pm,\n    'mean_x': PM25_scale_dic.getNumber('center'),\n    'sd_x': PM25_scale_dic.getNumber('scale')\n  }\n);\nEn la última imagen se encuentran los valores calculados de \\(PM_{2.5}\\) y esta es la imagen que vamos a desplegar en un mapa."
  },
  {
    "objectID": "posts/Modelo/Modelo.html#despliegue-en-mapa",
    "href": "posts/Modelo/Modelo.html#despliegue-en-mapa",
    "title": "Hacer modelos en GEE",
    "section": "Despliegue en mapa",
    "text": "Despliegue en mapa\nUsamos la imagen y la añadimos al mapa, como los valores mínimos y máximos van a ser de forma diaria para poder hacer una visualización buscamos los mínimos y máximos para ese día usando el método ee.Image.reduceRegion() la cual nos permite hacer uso de la operación reduce y ee.Reducer.minMax() para obtener el mínimo y el máximo.\nUna vez añadida la capa al mapa centramos el mapa al centro de la zona metropolitana.\n\nvar amm_roj = ['#ffffb2','#fecc5c','#fd8d3c','#f03b20','#bd0026'];\nvar min_max =  day_pm_re.reduceRegion(ee.Reducer.minMax(),ZMVM_bb)\nprint(min_max)\nvar max_pmval = min_max.get('PM_scale_max').getInfo();\nvar min_pmval = min_max.get('PM_scale_min').getInfo();\nMap.addLayer(\n  day_pm_re,\n  { \n    'bands':'PM_scale',\n    min : min_pmval,\n    max :max_pmval,\n    palette: amm_roj\n  }, 'PM 2.5'\n);\nMap.centerObject(ZMVM_bb, 10);\nAl final podemos observar como queda la estimación generada por el modelo.\n\n\n\nResultado Final"
  },
  {
    "objectID": "posts/Modelo/Modelo.html#comentario-final",
    "href": "posts/Modelo/Modelo.html#comentario-final",
    "title": "Hacer modelos en GEE",
    "section": "Comentario final",
    "text": "Comentario final\nEste tutorial donde mostramos que podemos hacer uso de distintas herramientas e integrarlas dentro de GEE."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]